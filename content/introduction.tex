\section{Introduction}
For the purposes of this paper, we current define usage management as the management of the usage of resources (and data) across and within computing environments.  More than access control or digital rights management, usage management concerns itself with fine-grained control of all aspects of how a given digital resource is used.  As digital environments become more open over time, the need for usage management for resources that span utility computational environments (e.g. cloud provider systems) will become increasingly important \cite{ctrl:lamb-MCCCS}.

With the advent and widespread use of cloud computing, those responsible for a given usage managed resource are almost never those responsible for the computing systems, except at edge devices like mobile phones or other small profile computing devices.  Resources are regularly moved across national boundaries and regional areas without either the content owner's or creator's knowledge.  Furthermore, this kind of transfer is generally according to pre-established algorithms or data routing protocols over which users of all stripes have no control.  Managing these kinds of issues requires new usage management capabilities that can run on platforms ranging from small, hand-held devices to nodes in large data centers.

Historically research in this area has been focused on developing more expressive policy languages via either different type of mathematical logics or formalisms with greater reasoning capabilities~\cite{ArHu:07,BaMi:06,ChCoEtHaJoLa:03,HaWe:04,HaWe:08,PuWe:02,XiBjFu:08}.  These approaches however fail to address interoperability challenges posed by new commercially available distributed computing environments.Interoperability efforts have resorted to translation mechanisms, where the policy is translated in its entirety to a different language~\cite{HeJa:05,PoPrDe:04,ScTaWo:04}; it has been shown recently however that such techniques are infeasible and hard to perform for most policy languages~\cite{KoLaMaMi:04, SaShUe:04}. Other approaches have led to complex policy specification languages that have tried to establish themselves as the universal standard~\cite{OMADRM,ODRL-req,Wa:04,XrML-spec}.  This unfortunately tends to stifle both innovation and flexibility~\cite{HeJa:05,JaHe:04,JaHe:08,JaHeMa:06}.

To address these issues, we first applied the principles of system design to develop a framework for usage management in open, distributed environments that supports interoperability. These principles have been used by researchers in large network design create a balance between interoperability and open, flexible architectures~\cite{Al:04,BlCl:01,ClWrSoBr:02}, allowing for computing scale and power without sacrificing innovation. Initially we standardized certain features of the framework operational semantics, and left free of standards features that necessitate choice and innovation.

We have implemented this framework, including a usage management calculus providing a platform usage management, within a Domain Specific Language (DSL) and associated evaluation environment. The DSL and its environment implements our previously defined framework, separating various roles needed for distributed policy creation and management, provides the capability to develop executable licenses, and is extensible from both a policy and constraint definition perspective.

In this paper, we will first review the problems in usage management in more detail, providing the context for this DSL and the problems it helps solve.  Then, in Section \ref{sec:model} we will first review the model we developed to guide the DSL's syntactic and semantic development.  Then, in the next section, we will cover the language itself, how it was developed, and its supporting evaluation environment.  We will then close the paper with three specific implemenation examples showing how the language and its runtime support usage management scenarios from three different environments --- creative commons (CC), the extensible rights markup language (XRML), and the open digital rights language(ODRL).

\section{Motivation}\label{sec:motivation}
As we covered in 2010 \cite{Jamkhedkar:2010:IUM:1866870.1866885}, usage management incorporates specific characteristics of traditional access control and digital rights management and incorporate encryption mechanisms, trust management, and trusted computing platforms.  In order to be effective, it must be flexible enough to provide users with opportunities for differentiation and extension, but interoperable enough to provide services across widely diverging computational environments.

This DSL and runtime provide flexibility through the inclusion of easily pluggable constraint and policy evaluators.  Both types of evaluators simply need to be locatable by the runtime, via standard classpath-style semantics.  If they are, they can be loaded and used with no other configuration required.  A policy file can simply reference the evaluator via a predefined language element, and the runtime will find it and load it automatically, using it to evaluate either the policy itself or the defined constraints (depending on whichever type of evaluator is specified).

The policy runtime elements can be dynamically loaded on host systems when required.  This provides interoperability by forcing the policy system itself to accept the responsibility of ensuring it is installed where required.  The technology upon which the runtime is based is widely available as well.  Additionally, the policies can be transferred from one host to another and can be directly executed upon delivery.  Furthermore, this language and system can express the semantics of common rights management environments, providing additional semantic flexibility and interoperability.

The DSL we describe, in tandem with its runtime, embodies an interoperable framework for usage management, unlike Coral and Marlin architectures, that implements a formal calculus to reason about the relationship between a license, a computing environment, and interoperability between them. It incorporates concepts such as programmable licenses and common ecosystems used by Coral and Marlin architectures respectively. The DSL design is based on the principles of {\em design for choice}, eloquently described by Clarke et al. with reference to ``tussles'' in cyberspace~\cite{ClWrSoBr:02}. They explain the importance of identify the locations in the architecture where standards need to be introduced to enable interoperability, and locations where they should {\em not} be applied to enable innovation and differentiation.  By supporting pluggable evaluators that allow users to extend the basic language syntax, semantics, and runtime arbitrarily, this language system provides space for innovation.
